Реализация
-----------

Тип аргументов предиката `sumti`:

> data Sumti = Sumti Quantifier SimpleSumti
>   deriving (Eq, Generic, Typeable)
> instance Textful Sumti where
>   untype (Sumti EmptyQ s) = untype s
>   untype (Sumti q s) = mkTNode (liftedUntype (q, s)) [] []

> data SimpleSumti where
>   La :: Word -> SimpleSumti
>   ProSumti :: KOhA -> SimpleSumti
>   LESumti :: forall n. LE -> LESumtiCtx -> Selbri n -> SimpleSumti
> instance Eq SimpleSumti where
>   (La w1) == (La w2) = w1 == w2
>   (ProSumti p1) == (ProSumti p2) = p1 == p2
>   (LESumti le1 ctx1 s1) ==  (LESumti le2 ctx2 s2) = 
>       and [le1 == le2, s1 `eqT1` s2]
> instance Textful SimpleSumti where
>   untype (La w) = TLeaf w
>   untype (ProSumti ps) = untype ps
>   untype (LESumti d c s) = mkTNode [] [untype d] $ liftedUntype (s, mkKu c)

Тип предикатов `selbri`, c известной арностью.
Включает простые однословные предикаты (`brivla`),
`tanru` --- сложные комбинированные предикаты и унарное отрицание предиката.

> data Selbri :: Nat -> * where
>   Brivla :: Word -> Selbri n
>   Tanru :: TanruOp -> TanruOpCtx -> Selbri l -> Selbri r -> Selbri r
>   NASelbri :: Selbri n -> Selbri n

> arityEq :: forall n m. (SingI n, SingI m) => 
>   Selbri n -> Selbri m -> Maybe (n :~: m)
> arityEq _ _ = (sing :: Sing n) `singEq` (sing :: Sing m)
> instance EqT Selbri where
>   x@(Brivla _) `eqT0` y@(Brivla _) = x `arityEq` y
>   x@(Tanru _ _ _ _) `eqT0` y@(Tanru _ _ _ _) = x `arityEq` y
>   (NASelbri s1) `eqT0` (NASelbri s2) = s1 `eqT0` s2 >>= return . liftEq
>   _ `eqT0` _ = Nothing
> instance Eq (Selbri n) where
>   x@(Brivla w1) == y@(Brivla w2) = and [x `eqT1` y, w1 == w2]
>   (Tanru op1 _ l1 r1) == (Tanru op2 _ l2 r2) =
>       and [op1 == op2, l1 `eqT1` l2, r1 `eqT1` r2]
>   (NASelbri s1) == (NASelbri s2) = s1 == s2
>   _ == _ = False

> instance Textful (Selbri n) where
>   untype (Brivla w) = TLeaf w
>   untype (Tanru op ctx l r) = mkTNode [untype $ mkKe ctx, ul] [untype op]
>                                       [ur, untype $ mkKe'e ctx] where
>       (ul, ur) = untypeArgsOrdered op l r
>       untypeArgsOrdered Co l r = (untype r, untype l)
>       untypeArgsOrdered _ l r = (untype l, untype r)
>   untype (NASelbri s) = mkTNode [untype Na] [untype s] []

Определение термов. Терм --- или аргумент (возможно, с тегом места),
или NA+KU (специальный терм для 'явной границы области естественного отрицания').
`TermPlacement` --- вид типов, обозначающих способ размещения аргумента.
`NaKuTerm` имеет вид размещения `TPPhantom` и не занимает слотов в предикате.
Можно заметить, что в типе `Term` отсутствует конструктор `IndexedNaKuTerm`
--- хотя это и разрешено формальной грамматикой, это бессмысленная конструкция.

> data TermPlacement = TPFixed Nat | TPAuto | TPPhantom
> data Term :: TermPlacement -> * where
>   SumtiTerm :: Sumti -> Term TPAuto
>   IndexedTerm :: FA n -> Sumti -> Term (TPFixed n)
>   NaKuTerm :: NA -> KU -> Term TPPhantom

> instance EqT Term where
>   SumtiTerm _ `eqT0` SumtiTerm _ = Just Refl
>   IndexedTerm tag _ `eqT0` IndexedTerm tag' _ = liftEq <$> tag `eqT0` tag'
>   NaKuTerm _ _ `eqT0` NaKuTerm _ _ = Just Refl
>   _ `eqT0` _ = Nothing
> instance Eq (Term n) where
>   SumtiTerm s == SumtiTerm s' = s `eqT` s'
>   IndexedTerm tag s == IndexedTerm tag' s' = and [tag == tag', s `eqT` s']
>   NaKuTerm na ku == NaKuTerm na' ku' = and [na == na', ku == ku']
>   _ == _ = False
> instance Textful (Term n) where
>   untype (SumtiTerm s) = untype s
>   untype (IndexedTerm tag s) = mkTNode [untype tag] [untype s] []
>   untype (NaKuTerm na ku) = mkTNode [] (liftedUntype (na, ku)) []

Определение списка термов. Вид `TermsState` определяется следующим образом 
--- в нём хранятся индекс следующего свободного слота и арность рассмотренной
части предиката. Объект типа `TermsF a b` --- это список (последовательность) термов,
стартующая в состоянии `a :: TermState` и заканчивающаяся в состоянии `b :: TermState`.
Существование такого объекта, одновременно, является доказательством существования
пути между этими состояниями.

> data TermsState = TState { nextPlaceIndex :: Nat, placeArity :: Nat }
> type TSDefault = TState 0 0

Преобразования между повышенными типами-одиночками и обычными типами, изоморфными им.

> newtype instance Sing (a :: TermsState) = STermsState (Integer, Integer)
> instance (SingI a, SingI b) => SingI (TState (a :: Nat) (b :: Nat)) where
>   sing = STermsState (fromSing (sing :: Sing a), fromSing (sing :: Sing b))
> instance SingE (KindOf (TState 0 0)) where
>   type DemoteRep (KindOf (TState 0 0)) = (Integer, Integer)
>   fromSing (STermsState s) = s
> singEq :: (SingE (kp :: KindIs k), Eq (DemoteRep (kp :: KindIs k))) =>
>   Sing (a :: k) -> Sing (b :: k) -> Maybe (a :~: b)
> singEq s1 s2 | fromSing s1 == fromSing s2 = Just (unsafeCoerce Refl)
>              | otherwise = Nothing

Непосредственное определение списка термов. Списки конструируются специальными операторами
`:#:`, `:#?` и `:#|`, выполняющими вычисление (в типах) нового состояния.

> type family TPFixedTermsF (n :: Nat) (s :: TermsState) :: TermsState
> type instance TPFixedTermsF n (TState nextI arity) =
>   TState (n + 1) (Max (n + 1) arity)
> type family TPAutoTermsF (s :: TermsState) :: TermsState
> type instance TPAutoTermsF (TState nextI arity) =
>   TState (nextI + 1) (arity + 1)
> data family TermsF (s0 :: TermsState) :: TermsState -> *
> data instance TermsF s0 sx where
>   TNil :: TermsF s0 s0
>   (:#:) :: (SingI (TPFixedTermsF n s)) =>
>           Term (TPFixed n) -> TermsF s0 s
>               -> TermsF s0 (TPFixedTermsF n s)
>   (:#?) :: (SingI (TPAutoTermsF s)) =>
>           Term TPAuto -> TermsF s0 s
>               -> TermsF s0 (TPAutoTermsF s)
>   (:#|) :: (SingI s) => Term TPPhantom -> TermsF s0 s -> TermsF s0 s
> nilTerm = TNil :: TermsF TSDefault TSDefault
> infixr 5 :#:
> infixr 5 :#?
> infixr 5 :#|

Сопутствующние экземпляры для `TermsF`: сравнение и вывод.

> instance EqT (TermsF s0) where
>   TNil `eqT0` TNil = Just Refl
>   (x :#: xs) `eqT0` (y :#: ys) =
>     let
>       prove :: forall n m x y. (SingI (TPFixedTermsF n x),
>                                 SingI (TPFixedTermsF m y)) =>
>           n :~: m -> x :~: y -> Maybe (TPFixedTermsF n x :~: TPFixedTermsF m y)
>       prove _ _ = (sing :: Sing (TPFixedTermsF n x)) `singEq`
>           (sing :: Sing (TPFixedTermsF m y))
>     in do {p1 <- x `eqT0` y; p2 <- xs `eqT0` ys; prove (lower p1) p2;}
>   (_ :#? xs) `eqT0` (_ :#? ys) = (xs `eqT0` ys) >>= prove where
>       prove :: forall x y. (SingI (TPAutoTermsF x), SingI (TPAutoTermsF y)) =>
>           x :~: y -> Maybe (TPAutoTermsF x :~: TPAutoTermsF y)
>       prove _ = (sing :: Sing (TPAutoTermsF x)) `singEq`
>           (sing :: Sing (TPAutoTermsF y))
>   (_ :#| xs) `eqT0` (_ :#| ys) = xs `eqT0` ys
>   _ `eqT0` _ = Nothing
>   
> instance Eq (TermsF s0 s) where
>   TNil == TNil = True
>   (x :#: xs) == (y :#: ys) = and [x `eqT1` y, xs `eqT1` ys]
>   (x :#? xs) == (y :#? ys) = and [x == y, xs `eqT1` ys]
>   (x :#| xs) == (y :#| ys) = and [x == y, xs `eqT1` ys]

> untypeTermsF' :: TermsF s0 s -> [TextTree]
> untypeTermsF' TNil = []
> untypeTermsF' (x :#: xs) = untype x : untypeTermsF' xs
> untypeTermsF' (x :#? xs) = untype x : untypeTermsF' xs
> untypeTermsF' (x :#| xs) = untype x : untypeTermsF' xs
> instance Textful (TermsF s0 s) where
>   untype xs = mkTNode (untypeTermsF' xs) [] []

Хвосты высказываний (англ. `bridi`-tails) представляют собой
расходящиеся части логически объединённого сложного высказывания.
Например, `mi klama le zarci .ije mi nelci la djan.` эквивалентно
`mi klama le zarci gi'e nelci la djan.`. Структура параметров типа аналогична
`TermsF`.

> data family BridiTailF (s :: TermsState) :: TermsState -> *
> data instance BridiTailF s0 sx where
>   SelbriBT :: (arity <= n) => Selbri n -> TermsF s0 (TState ni arity)
>       -> BridiTailF s0 (TState ni arity)
> instance Textful (BridiTailF s0 s) where
>   untype (SelbriBT s ts) = mkTNode [] [untype s] [untype ts]

Тип высказывания:

> data Bridi :: Nat -> * where
>   Bridi :: TermsF TSDefault s0 -> BridiTailF s0 (TState ni arity) -> Bridi arity
> instance Textful (Bridi arity) where
>   untype (Bridi prefix tail) = mkTNode [untype prefix] [untype tail] []

Функции для создания простых высказываний:

> bridi1 :: Selbri 1 -> Sumti -> Bridi 1
> bridi1 s x1 = Bridi (SumtiTerm x1 :#? TNil) $ SelbriBT s TNil
> bridi2 :: Selbri 2 -> Sumti -> Sumti -> Bridi 2
> bridi2 s x1 x2 = Bridi (SumtiTerm x1 :#? TNil) $ SelbriBT s 
>   (SumtiTerm x2 :#? TNil)
> bridi3 :: Selbri 3 -> Sumti -> Sumti -> Sumti -> Bridi 3
> bridi3 s x1 x2 x3 = Bridi (SumtiTerm x1 :#? TNil) $ SelbriBT s
>   (SumtiTerm x2 :#? SumtiTerm x3 :#? TNil)
> bridi4 :: Selbri 4 -> Sumti -> Sumti -> Sumti -> Sumti -> Bridi 4
> bridi4 s x1 x2 x3 x4 = Bridi (SumtiTerm x1 :#? TNil) $ SelbriBT s
>   (SumtiTerm x2 :#? SumtiTerm x3 :#? SumtiTerm x4 :#? TNil)

Теги индексов слотов (FA):

> data FA :: Nat -> * where
>   Fa :: FA 0
>   Fe :: FA 1
>   Fi :: FA 2
>   Fo :: FA 3
>   Fu :: FA 4
> instance EqT FA where
>   Fa `eqT0` Fa = Just Refl
>   Fe `eqT0` Fe = Just Refl
>   Fi `eqT0` Fi = Just Refl
>   Fo `eqT0` Fo = Just Refl
>   Fu `eqT0` Fu = Just Refl
>   _ `eqT0` _ = Nothing
> deriving instance Eq (FA n)
> deriving instance Show (FA n)

> instance Textful (FA n) where
>   untype Fa = TLeaf "Fa"
>   untype Fe = TLeaf "Fe"
>   untype Fi = TLeaf "Fi"
>   untype Fo = TLeaf "Fo"
>   untype Fu = TLeaf "Fu"
> tagIndex :: forall n. SingI n => FA n -> Int
> tagIndex _ = fromInteger $ fromSing (sing :: Sing n)

Определение `tanru` --- сложных комбинированных предикатов.

Контекст кодирует наличие опциональных скобок `ke ... ke'e`.

> data KeState = HasKEAndKEhE | HasKE | HasNone

> data TanruOpCtx = TanruOpCtx { keState :: KeState }
> defaultTC :: TanruOpCtx
> defaultTC = TanruOpCtx { keState = HasNone }

> mkKe :: TanruOpCtx -> Elidable KE
> mkKe c = case keState c of
>   HasNone -> Nothing
>   _       -> Just Ke
> mkKe'e :: TanruOpCtx -> Elidable KEhE
> mkKe'e c = case keState c of
>   HasKEAndKEhE -> Just Ke'e
>   _            -> Nothing

Операторы, образующий `tanru` --- сложные комбинированные предикаты:

 - ``Selbri `tanruApp` Selbri``: пишется как "Selbri Selbri", приоритет 6, левоассоциативный
 - ``Selbri `bo` Selbri``: приоритет 9, правоассоциативный
 - ``ke [Selbri]``: пишется как "ke Selbri Selbri ... Selbri [ke'e]", скобки
 - ``Selbri `co` Selbri``: инверсия порядка, приоритет 5, правоассоциативный, разбивает ke...ke'e

> data TanruOp = GroupApp | Bo | Co deriving (Eq, Generic)
> instance Textful TanruOp where
>   untype GroupApp = emptyTNode
>   untype Bo = TLeaf "bo"
>   untype Co = TLeaf "co"

> modifyTanruOpCtx :: (TanruOpCtx -> TanruOpCtx) -> Selbri n -> Selbri n
> modifyTanruOpCtx f (Tanru op c l r) = Tanru op (f c) l r

> infixl 6 `tanruApp`
> tanruApp :: Selbri l -> Selbri r -> Selbri r
> l `tanruApp` r = Tanru GroupApp defaultTC l r
> infixr 9 `bo`
> bo :: Selbri l -> Selbri r -> Selbri r
> l `bo` r = Tanru Bo defaultTC l r
> infixr 5 `co`
> co :: Selbri r -> Selbri l -> Selbri r
> r `co` l = Tanru Co defaultTC l r

> updateKeState :: KeState -> Selbri n -> Selbri n
> updateKeState s = modifyTanruOpCtx (\c -> c {keState = s})
> ke :: Selbri n -> Selbri n
> ke = updateKeState HasKE
> keKe'e :: Selbri n -> Selbri n
> keKe'e = updateKeState HasKEAndKEhE

Дескрипторы (артикли) --- преобразование предикатов в аргументы.

> data LESumtiCtx = LESumtiCtx { hasKu :: Bool }
> defaultLEC :: LESumtiCtx
> defaultLEC = LESumtiCtx { hasKu = False }
> mkKu :: LESumtiCtx -> Elidable KU
> mkKu c = if hasKu c then Just Ku else Nothing


> lo :: (Selbri n s) => s -> LESumti
> lo = LESumti Lo defaultLEC
> loKu :: (Selbri n s) => s -> LESumti
> loKu = LESumti Lo defaultLEC { hasKu = True }



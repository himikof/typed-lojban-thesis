Реализация
-----------

Sumti class:

> class (Eq w, Textful w, Typeable w, FGTaggable w) => Sumti w where

Universal contradictory negator NA cmavo.

> data NA = Na deriving (Eq, Generic, Typeable)
> instance Textful NA where

Defining selbri and brivla (arity-constrained):

> data SelbriPlace = SelbriPlace {
>   explicitZo'e :: Bool,
>   tag :: Elidable (FA 0)
> }
> deriving instance Eq (SelbriPlace)
> deriving instance Show (SelbriPlace)
> defaultSP :: SelbriPlace
> defaultSP = SelbriPlace {explicitZo'e = False, tag = Nothing}

> data SelbriCtx = SCtx { 
>   hasCu :: Bool,
>   places :: Maybe [SelbriPlace]
> } deriving (Eq, Show)
> defaultSC :: SelbriCtx
> defaultSC = SCtx { hasCu = False, places = Nothing }
> {-# DEPRECATED SelbriPlace,SelbriCtx,defaultSP,defaultSC "Old" #-}

> class (Eq t, Textful t, Typeable t, FGTaggable t) => Selbri (n :: Nat) t | t -> n where

> data Brivla :: Nat -> * where
>   Brivla :: Word -> Brivla n
> deriving instance Eq (Brivla n)

Brivla cannot be in Typeable1, because its kind is Nat -> *, not * -> *.
So we make use of T'.Typeable and instance (T'.Typeable t, T'.Typeable a) => Typeable (t a).
So Brivla Nat1, for example, is in Typeable as well as T'.Typeable.

> instance T'.Typeable (Brivla) where
> instance Textful (Brivla n) where
>   untype (Brivla w) = TLeaf w
> instance T'.Typeable n => FGTaggable (Brivla n) where
>   type FGTagged (Brivla n) = SelbriFGT n
>   withFGTagC = SelbriFGT
> instance T'.Typeable n => Selbri n (Brivla n) where

Term definition. Term is a (maybe tagged) sumti or a
termset (compound term) or a KU/NA+KU (indicating no sumti).
The datatype parameter is the place index or a Bool indicating
that the place should receive the next index.
There is no IndexedKuTerm, because that does not make sense
(albeit being grammatically correct).
Note that NaKuTerm is not a selbri per se, but has the same
grammatical structure, meaning 'explicit negation span boundary'.
Therefore, it does not occpuy any selbri slots.
TODO: TaggedTerm, TaggedKuTerm and CompoundTerm constructors.

> data TermPlacement = TPFixed Nat | TPAuto | TPPhantom
> data Term :: TermPlacement -> * where
>   SumtiTerm :: Sumti s => s -> Term TPAuto
>   IndexedTerm :: Sumti s => FA n -> s -> Term (TPFixed n)
>   NaKuTerm :: NA -> KU -> Term TPPhantom
> instance T'.Typeable ('TPFixed) where
> instance T'.Typeable (Term) where
> instance Eq (Term n) where
>   SumtiTerm s == SumtiTerm s' = s `eqT` s'
>   IndexedTerm tag s == IndexedTerm tag' s' = and [tag == tag', s `eqT` s']
>   NaKuTerm na ku == NaKuTerm na' ku' = and [na == na', ku == ku']
>   _ == _ = False
> instance Textful (Term n) where
>   untype (SumtiTerm s) = untype s
>   untype (IndexedTerm tag s) = mkTNode [untype tag] [untype s] []
>   untype (NaKuTerm na ku) = mkTNode [] (liftedUntype (na, ku)) []

Term list definition. The data type second parameter encodes
the next place index and place arity (maximum used index).
Essentially, an object of type `TermsF a b` is a
term sequence from state `a :: TermState` to `b :: TermState`.

> data TermsState = TState { nextPlaceIndex :: Nat, placeArity :: Nat }
> instance T'.Typeable ('TState) where
> data family TermsF (s0 :: TermsState) :: TermsState -> *
> data instance TermsF s0 sx where
>   TNil :: TermsF s0 s0
>   (:#:) :: {-(T'.Typeable n, T'.Typeable s0, T'.Typeable nextI, T'.Typeable arity) =>-}
>           Term (TPFixed n) -> TermsF s0 (TState nextI arity)
>               -> TermsF s0 (TState (n + 1) (Max (n + 1) arity))
>   (:#?) :: {-(T'.Typeable s0, T'.Typeable nextI, T'.Typeable arity) =>-}
>           Term TPAuto -> TermsF s0 (TState nextI arity)
>               -> TermsF s0 (TState (nextI + 1) (arity + 1))
> infixr 5 :#:
> infixr 5 :#?
> instance T'.Typeable (TermsF) where
> {- disabled until GHC 7.8
> instance Eq (TermsF s0 s) where
>   TNil == TNil = True
>   (x :#: xs) == (y :#: ys) = and [x `eqT` y, xs `eqT` ys]
>   (x :#? xs) == (y :#? ys) = and [x == y, xs `eqT` ys]-}

> untypeTermsF' :: TermsF s0 s -> [TextTree]
> untypeTermsF' TNil = []
> untypeTermsF' (x :#: xs) = untype x : untypeTermsF' xs
> untypeTermsF' (x :#? xs) = untype x : untypeTermsF' xs
> instance Textful (TermsF s0 s) where
>   untype xs = mkTNode (untypeTermsF' xs) [] []

Bridi tail (compound bridi) definitions.
A bridi tail is a divergent part of a logically merged bridi group.
For example: `mi klama le zarci .ije mi nelci la djan.` is equivalent to
`mi klama le zarci gi'e nelci la djan.`. The data type parameter encodes
maximum used place index.

> data family BridiTailF (s :: TermsState) :: TermsState -> *
> data instance BridiTailF s0 sx where
>   SelbriBT :: (T'.Typeable n, Selbri n s) => s -> TermsF s0 (TState ni arity)
>       -> BridiTailF s0 (TState ni arity)
> instance Textful (BridiTailF s0 s) where
>   untype (SelbriBT s ts) = mkTNode [] [untype s] [untype ts]

> data Bridi' :: Nat -> * where
>   Bridi' :: TermsF (TState 0 0) s0 -> BridiTailF s0 (TState ni arity) -> Bridi' arity
> instance Textful (Bridi' arity) where
>   untype (Bridi' prefix tail) = mkTNode [untype prefix] [untype tail] []

FA tag cmavo:

TODO: CLL/9/3: support fi'a (in FA) - place structure question

> data FA :: Nat -> * where
>   Fa :: FA 0
>   Fe :: FA 1
>   Fi :: FA 2
>   Fo :: FA 3
>   Fu :: FA 4
> deriving instance Eq (FA n)
> deriving instance Show (FA n)

> instance Textful (FA n) where
>   untype Fa = TLeaf "Fa"
>   untype Fe = TLeaf "Fe"
>   untype Fi = TLeaf "Fi"
>   untype Fo = TLeaf "Fo"
>   untype Fu = TLeaf "Fu"
> tagIndex :: forall n. SingI n => FA n -> Int
> tagIndex _ = fromInteger $ fromSing (sing :: Sing n)

CU cmavo:

> data CU = Cu deriving (Eq, Generic)
> instance Textful CU where

Elidable functor:

> type Elidable = Maybe
> instance Textful t => Textful (Elidable t) where
>   untype = maybe emptyTNode untype

Some helpers for bridi implementation:

> mkCu :: SelbriCtx -> Elidable CU
> mkCu c = if hasCu c then Just Cu else Nothing

> class GLiftedUntype f where
>   gliftedUntype :: f a -> [TextTree]
> instance GLiftedUntype U1 where
>   gliftedUntype U1 = []
> instance (GLiftedUntype a, GLiftedUntype b) => GLiftedUntype (a :*: b) where
>   gliftedUntype (a :*: b) = gliftedUntype a ++ gliftedUntype b
> instance (GLiftedUntype a) => GLiftedUntype (M1 i c a) where
>   gliftedUntype (M1 x) = gliftedUntype x
> instance (Textful a) => GLiftedUntype (K1 i a) where
>   gliftedUntype (K1 x) = [untype x]

> liftedUntype :: (Generic a, GLiftedUntype (Rep a)) => a -> [TextTree]
> liftedUntype = gliftedUntype . from

> eqT :: (Eq a, Typeable a, Typeable b) => a -> b -> Bool 
> eqT a b = Just a == cast b

Main bridi datatype:

CU is already supported.

Sumti slot remapper (planned):

 - Support moving selbri around (x1 x2 selbri x3, for example).
 - Support zo'e omission
 - Think about exact string preserving after roundtrip.
 - BE/BEI/BEhO linked sumti

TODO: CLL/9/3: Actually, there may be more than one Sumti in a slot, using FA tags.
How can it be typed?

> data Bridi where
>   Bridi1 :: (Selbri 1 s, Sumti x1)
>       => s -> SelbriCtx -> x1 -> Bridi
>   Bridi2 :: (Selbri 2 s, Sumti x1, Sumti x2)
>       => s -> SelbriCtx -> x1 -> x2 -> Bridi
>   Bridi3 :: (Selbri 3 s, Sumti x1, Sumti x2, Sumti x3)
>       => s -> SelbriCtx -> x1 -> x2 -> x3 -> Bridi
>   Bridi4 :: (Selbri 4 s, Sumti x1, Sumti x2, Sumti x3, Sumti x4)
>       => s -> SelbriCtx -> x1 -> x2 -> x3 -> x4 -> Bridi
> instance Eq Bridi where
>   Bridi1 s _ x1 == Bridi1 s' _ x1' = and [s `eqT` s', x1 `eqT` x1']
>   Bridi2 s _ x1 x2 == Bridi2 s' _ x1' x2' = 
>       and [s `eqT` s', x1 `eqT` x1', x2 `eqT` x2']
>   Bridi3 s _ x1 x2 x3 == Bridi3 s' _ x1' x2' x3' =
>       and [s `eqT` s', x1 `eqT` x1', x2 `eqT` x2', x3 `eqT` x3']
>   Bridi4 s _ x1 x2 x3 x4 == Bridi4 s' _ x1' x2' x3' x4' =
>       and [s `eqT` s', x1 `eqT` x1', x2 `eqT` x2', x3 `eqT` x3', x4 `eqT` x4']
>   _ == _ = False
> instance Textful Bridi where
>   untype (Bridi1 s c x1) = untypeBridi (untype s) c [untype x1]
>   untype (Bridi2 s c x1 x2) = untypeBridi (untype s) c $ liftedUntype (x1, x2)
>   untype (Bridi3 s c x1 x2 x3) = untypeBridi (untype s) c $
>       liftedUntype (x1, x2, x3)
>   untype (Bridi4 s c x1 x2 x3 x4) = untypeBridi (untype s) c $
>       liftedUntype (x1, x2, x3, x4)
> {-# DEPRECATED Bridi "old" #-}

TODO: Check places structure for correctness.

> untypeBridi :: TextTree -> SelbriCtx -> [TextTree] -> TextTree
> untypeBridi s ctx sumtis = layoutBridi sumtis (untype $ mkCu ctx, s) ctx

> layoutBridiPlaces :: [SelbriPlace] -> [TextTree] -> [Maybe TextTree]
> layoutBridiPlaces places sumtis = evalState (mapM f places) 0 where
>   f :: SelbriPlace -> State Int (Maybe TextTree)
>   f place = 
>       case tag place of
>            Nothing -> do
>               sumti <- liftM (sumtis !!) $ get
>               modify (+1)
>               return $ Just sumti
>            Just tag -> do
>               put $ tagIndex tag + 1
>               let sumti = sumtis !! tagIndex tag
>               return $ Just $ mkTNode [] [untype tag] [sumti]

> layoutBridi :: [TextTree] -> (TextTree, TextTree) -> SelbriCtx -> TextTree
> layoutBridi sumtis (cu, selbri) ctx = mkTNode' $
>   case ctx of
>       (places -> Nothing) -> doLayout defPlaces
>       (places -> Just places) -> doLayout places
>   where defPlace = SelbriPlace {explicitZo'e = False, tag = Nothing}
>         defPlaces = take (length sumtis) $ repeat $ defPlace
>         doLayout ps = layout $ catMaybes $ layoutBridiPlaces ps sumtis
>         layout [] = ([cu], [selbri], [])
>         layout (t:ts) = ([t, cu], [selbri], ts)

Tanru - complex selbri, recursively defined.
Operators: 

 - ``Selbri `tanruApp` Selbri``: written as "Selbri Selbri", priority 6, left-associative
 - ``Selbri `bo` Selbri``: priority 9, right-associative
 - ``ke [Selbri]``: written as "ke Selbri Selbri ... Selbri [ke'e]", scoped
 - ``Selbri `JA` Selbri``: logical connectives, priority 8, left-associative
 - ``Selbri `JAbo` Selbri``: logical connectives, priority 7, left-associative
 - ``Selbri `co` Selbri``: inversion, priority 5, right-associative, cannot be inside ke...ke'e

TODO: JA, JAbo, prohibit co inside ke...ke'e

> data KeState = HasKEAndKEhE | HasKE | HasNone

KE and KEhE cmavo:

> data KE = Ke deriving (Eq, Generic)
> instance Textful KE where
> data KEhE = Ke'e deriving (Eq, Generic)
> instance Textful KEhE where

> data TanruOpCtx = TanruOpCtx { keState :: KeState }
> defaultTC :: TanruOpCtx
> defaultTC = TanruOpCtx { keState = HasNone }

> mkKe :: TanruOpCtx -> Elidable KE
> mkKe c = case keState c of
>   HasNone -> Nothing
>   _       -> Just Ke
> mkKe'e :: TanruOpCtx -> Elidable KEhE
> mkKe'e c = case keState c of
>   HasKEAndKEhE -> Just Ke'e
>   _            -> Nothing

> class (Eq w, Textful w, Typeable w) => TanruOp w where
>   untypeArgsOrdered :: (Selbri m l, Selbri n r) => w -> l -> r -> (TextTree, TextTree)
>   untypeArgsOrdered _ l r = (untype l, untype r)

> data TanruApp = TanruApp deriving (Eq, Typeable)
> instance Textful TanruApp where
>   untype = const emptyTNode
> instance TanruOp TanruApp where

> data BO = Bo deriving (Eq, Generic, Typeable)
> instance Textful BO where
> instance TanruOp BO where

> data CO = Co deriving (Eq, Generic, Typeable)
> instance Textful CO where
> instance TanruOp CO where
>   untypeArgsOrdered _ l r = (untype r, untype l)

> data Tanru :: Nat -> * where
>   Tanru :: (TanruOp op, Selbri m l, Selbri n r) => 
>           op -> TanruOpCtx -> l -> r -> Tanru n

> instance (T'.Typeable n) => Selbri n (Tanru n) where
> instance Textful (Tanru n) where
>   untype (Tanru op c l r) = mkTNode [untype $ mkKe c, ul] [untype op]
>                                     [ur, untype $ mkKe'e c] where
>       (ul, ur) = untypeArgsOrdered op l r
> instance Eq (Tanru n) where 
>   Tanru op _ l r == Tanru op' _ l' r' = and [op `eqT` op', l `eqT` l', r `eqT` r']
> instance T'.Typeable Tanru where
>   typeOf = \_ -> rep where
>       rep = defaultSingTyRep "Tanru"
> instance T'.Typeable n => FGTaggable (Tanru n) where
>   type FGTagged (Tanru n) = SelbriFGT n
>   withFGTagC = SelbriFGT

> modifyTanruOpCtx :: (TanruOpCtx -> TanruOpCtx) -> Tanru n -> Tanru n
> modifyTanruOpCtx f (Tanru op c l r) = Tanru op (f c) l r

> infixl 6 `tanruApp`
> tanruApp :: (Selbri m l, Selbri n r) => l -> r -> Tanru n
> l `tanruApp` r = Tanru TanruApp defaultTC l r
> infixr 9 `bo`
> bo :: (Selbri m l, Selbri n r) => l -> r -> Tanru n
> l `bo` r = Tanru Bo defaultTC l r
> infixr 5 `co`
> co :: (Selbri m l, Selbri n r) => r -> l -> Tanru n
> r `co` l = Tanru Co defaultTC l r

> updateKeState :: KeState -> Tanru n -> Tanru n
> updateKeState s = modifyTanruOpCtx (\c -> c {keState = s})
> ke :: Tanru n -> Tanru n
> ke = updateKeState HasKE
> keKe'e :: Tanru n -> Tanru n
> keKe'e = updateKeState HasKEAndKEhE

KU cmavo:

> data KU = Ku deriving (Eq, Generic)
> instance Textful KU where

Descriptors - selbri to sumti conversion

TODO: implement other LE members - le, le'e, le'i, lo'e, lo'i, loi, etc

> data LESumtiCtx = LESumtiCtx { hasKu :: Bool }
> defaultLEC :: LESumtiCtx
> defaultLEC = LESumtiCtx { hasKu = False }
> mkKu :: LESumtiCtx -> Elidable KU
> mkKu c = if hasKu c then Just Ku else Nothing

> data LE = Lo deriving (Eq, Generic, Typeable)
> instance Textful LE where
> lo :: (Selbri n s) => s -> LESumti
> lo = LESumti Lo defaultLEC
> loKu :: (Selbri n s) => s -> LESumti
> loKu = LESumti Lo defaultLEC { hasKu = True }

> data LESumti where
>   LESumti :: (Selbri n s) => LE -> LESumtiCtx -> s -> LESumti
> deriving instance (Typeable LESumti)
> instance Eq LESumti where
>   LESumti d _ s == LESumti d' _ s' = and [d == d', s `eqT` s']
> instance Textful LESumti where
>   untype (LESumti d c s) = mkTNode [] [untype d] $ liftedUntype (s, mkKu c)
> instance FGTaggable LESumti where
>   type FGTagged LESumti = SumtiFGT
>   withFGTagC = SumtiFGT
> instance Sumti LESumti where

Free grammar transformers: attitudinals and such

TODO: implement bridi tagging

> class (Eq t, Typeable t, Textful t) => FreeGrammarTag t where

> class FGTaggable w where
>   type FGTagged w :: *
>   withFGTagC :: (FreeGrammarTag t) => t -> FGTransCtx -> w -> FGTagged w
>   withFGTag :: (FreeGrammarTag t) => t -> w -> FGTagged w
>   withFGTag t = withFGTagC t defaultFGTC

> data FGTransCtx = FGTransCtx { suffixPosition :: Bool }
> defaultFGTC :: FGTransCtx
> defaultFGTC = FGTransCtx { suffixPosition = False }

> defaultFreeGrammarUntype :: (Textful w, FreeGrammarTag t) => 
>                             t -> FGTransCtx -> w -> TextTree
> defaultFreeGrammarUntype t c w = mkTNode' $ 
>       if suffixPosition c
>       then ([untype w], [untype t], [])
>       else case untype w of
>                 su@(TLeaf _) -> ([su], [untype t], [])
>                 TNode l c r -> (l, c ++ [untype t], r)

> data SumtiFGT where
>   SumtiFGT :: (Sumti s, FreeGrammarTag t) => t -> FGTransCtx -> s -> SumtiFGT
> deriving instance (Typeable SumtiFGT)
> instance Eq SumtiFGT where
>   SumtiFGT t _ s == SumtiFGT t' _ s' = and [t `eqT` t', s `eqT` s']
> instance Textful SumtiFGT where
>   untype (SumtiFGT t c s) = defaultFreeGrammarUntype t c s
> instance FGTaggable SumtiFGT where
>   type FGTagged SumtiFGT = SumtiFGT
>   withFGTagC = SumtiFGT
> instance Sumti SumtiFGT where

> data SelbriFGT :: Nat -> * where
>   SelbriFGT :: (Selbri n s, FreeGrammarTag t) => t -> FGTransCtx -> s -> SelbriFGT n
> instance T'.Typeable SelbriFGT where
>   typeOf = \_ -> rep where
>       rep = defaultSingTyRep "SelbriFGT"
> instance Eq (SelbriFGT n) where
>   SelbriFGT t _ s == SelbriFGT t' _ s' = and [t `eqT` t', s `eqT` s']
> instance Textful (SelbriFGT n) where
>   untype (SelbriFGT t c s) = defaultFreeGrammarUntype t c s
> instance T'.Typeable n => FGTaggable (SelbriFGT n) where
>   type FGTagged (SelbriFGT n) = SelbriFGT n
>   withFGTagC = SelbriFGT
> instance T'.Typeable n => Selbri n (SelbriFGT n) where


Особенности типизации языка Ложбан
----------------------------------

Как показывает эта работа, от системы типов необходимо наличие натуральных
чисел на уровне типов и функций на типах. Данная работа сосредотачивается на
использовании языка (а, точнее, семейства языков) Haskell[@haskell],
использующего в качестве системы типов различные расширения 
System $F_C$[@tt:sulzmann2007system].

### Доказательства на уровне типов ###

В основе идеи представления доказательств внутри системы типов лежит
соответствие Карри — Ховарда[@tt:sørensen2006lectures], связывающее
истинность высказываний некоторых логик с населённостью типов в
соответствующих системах типов. В частности, это позволяет доказывать
логические теоремы написанием корректной функции, имеющей тип,
соответствующий формулировке теоремы.

### Натуральные числа на уровне типов ###

Несмотря на то, что все числа, хранящися на уровне типов в данной работе,
ограничены небольшой константой (благодаря свойствам языка Ложбан, в частности,
ограниченной максимальной кратности предиката), данная работа в целях
упрощения реализации, уменьшения дублирования и обобщения предполагает наличие
натуральных чисел на уровне типов. Как будет показано ниже, этой цели можно
достичь, оставаясь в рамках языка Haskell и не жертвуя автоматическим 
выводом типов.

Язык Haskell как метаязык для типизации
---------------------------------------

Как уже упоминалось выше, Haskell --- не
один язык, а семейство языков, разные аспекты (возможности) которых 
настраиваются расширениями языка, причём языки с разными множествами
опций могут очень сильно отличаться по выразительной мощности. Поэтому
одной из целей работы было нахождение и обоснование разумного множества
расширений, дающих систему типов достаточной выразительности.

### GADT и фантомные типы ###

Использование обобщённых алгебраических типов данных (*англ.* GADT) вместе с фантомными
типами для представления[@tt:Washburn03boxesgo] AST на языке Haskell является 
широко известой техникой. 

Строго говоря, GADT не являются необходимыми для составления типа.
Для каждого значения параметров, подставляемых в возвращаемый тип GADT,
все вхождения этого GADT можно заменить на уникальный тип. Но с практической
точки зрения такое преобразование мало осмысленно, т.к. только для записи
типа `TermsF` потребовалось бы как минимум $n^4$ уникальных типов, 
где n --- максимальная кратность предиката (в Ложбан $n=5$). Код, выполняющий
операции над этими типами, увеличился бы пропорционально.

В данной работе в фантомных типах узлов дерева хранится информация, 
позволяющая проверять некоторые семантические условия в AST.

### Вычисления на уровне типов ###

Для написания функций, принимающих типы на вход,
используется расширение `TypeFamilies` --- семейства типов[@tt:Kiselyov10funwith][@tt:Chakravarty:2005:ATC:1047659.1040306].
Это позволяет относительно легко объявлять функции на типах, преобразующие соответствующим образом хранимое состояние.
Также в этом помогает синтаксическое расширение `TypeOperators`, позволяющее объявлять на типах произвольные инфиксные операторы.

### Виды типов и полиморфизм по видам ###

Вид типа (*англ.* kind) --- это тип типов, т.е. некоторое множество типов. Все обычные типы принадлежат к виду `*`, обычные унарные конструкторы
типов к виду \lstinline$* -> *$ и так далее.
Использование расширений `KindSignatures` и `DataKinds` позволяет вводить новые виды путём повышения[@tt:Yorgey:2012:GHP:2103786.2103795] обычных типов до видов типов,
а населяющих их значений до типов, населяющих вид. В частности, это позволяет повысить натуральные числа до типов вида `Nat`, и не выполнять ручного кодирования
через аксиомы Пеано.
Расширение `PolyKinds`[@tt:Yorgey:2012:GHP:2103786.2103795], добавляющее полиморфизм по видам, позволяет, в свою очередь, сформулировать некоторые свойства для
всех видов сразу. Это упрощает, например, определение операции сравнения на типах.

### Натуральные числа и операции над ними на уровне типов ###

Используя комбинацию расширений языка `TypeFamilies`, `DataKinds` и `TypeOperators`
можно достаточно удобно реализовать вычисления над натуральными числами:

````haskell
type family If' (c :: Bool) (a :: k) (b :: k) :: k
type instance If' True a b = a
type instance If' False a b = b

type family Max (m :: Nat) (n :: Nat) :: Nat
type instance Max m n = If' (m <=? n) n m
````

К сожалению, в текущей версии компилятора GHC алгоритм, проверяющий выполнение условий на то, что
проверка типов завершится за конечное время, не поддерживает произвольно вложенное
применение функций на типах. Соответственно, некоторая часть кода, выполняющая
арифметику на уровне типов, требует расширения `UndecidableInstances`, отключающего
проверку данных условий. Для этого кода данное расширение безопасно, т.к.
любые арифметические действия завершаются за конечное время, 
даже если компилятор не способен доказать это автоматически.

